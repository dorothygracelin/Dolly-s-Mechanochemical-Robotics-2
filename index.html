<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biomedical Soft Robot - 3D Simulation Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
            cursor: move;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 350px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #info-panel h1 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #4fc3f7;
        }

        #info-panel h2 {
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
            color: #81c784;
        }

        #info-panel p, #info-panel ul {
            font-size: 13px;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        #info-panel ul {
            list-style-position: inside;
            padding-left: 10px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #controls h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #4fc3f7;
        }

        #controls p {
            font-size: 12px;
            margin: 5px 0;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .active {
            background-color: #4caf50;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="info-panel">
            <h1>ü§ñ Biomedical Soft Robot</h1>
            <p><strong>Magnetite-Derived Magnetic Product</strong></p>
            
            <h2>Characteristics:</h2>
            <ul>
                <li>Miniature bug-like appearance</li>
                <li>Spreadable magnetic material</li>
                <li>AI spectroscopic sensing</li>
                <li>Universal flexibility</li>
            </ul>
            
            <h2>Capabilities:</h2>
            <p>
                <span class="status-indicator active"></span>
                <strong>AI Spectroscopic Sensing:</strong> Real-time analysis of surrounding materials and biological tissues
            </p>
            <p>
                <span class="status-indicator active"></span>
                <strong>Magnetic Navigation:</strong> Precise positioning via external magnetic fields
            </p>
            <p>
                <span class="status-indicator active"></span>
                <strong>Adaptive Morphology:</strong> Shape-changing capabilities for navigation through complex environments
            </p>
        </div>

        <div id="controls">
            <h3>üéÆ Controls</h3>
            <p>üñ±Ô∏è <strong>Mouse Move:</strong> Rotate view</p>
            <p>üîç <strong>Scroll:</strong> Zoom in/out</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let time = 0;
        let mouseX = 0, mouseY = 0;
        let rotationY = 0, rotationX = 0;
        let zoom = 1;
        let particles = [];

        // Initialize
        function init() {
            resize();
            initParticles();
            
            canvas.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / width - 0.5) * 2;
                mouseY = (e.clientY / height - 0.5) * 2;
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoom += e.deltaY * -0.001;
                zoom = Math.max(0.5, Math.min(2, zoom));
            });
            
            window.addEventListener('resize', resize);
            animate();
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                particles.push({
                    angle: angle,
                    radius: 3 + Math.random(),
                    speed: 0.2 + Math.random() * 0.3,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        // 3D transformation functions
        function rotateXFunc(p, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: p.x,
                y: p.y * cos - p.z * sin,
                z: p.y * sin + p.z * cos
            };
        }

        function rotateYFunc(p, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: p.x * cos + p.z * sin,
                y: p.y,
                z: -p.x * sin + p.z * cos
            };
        }

        function project(p) {
            const perspective = 400 / (p.z + 6);
            return {
                x: p.x * perspective * zoom + width / 2,
                y: -p.y * perspective * zoom + height / 2,
                size: perspective * zoom
            };
        }

        function transform(p, rx, ry) {
            let point = rotateYFunc(p, ry);
            point = rotateXFunc(point, rx);
            return project(point);
        }

        // Drawing functions
        function drawSphere(x, y, z, radius, color, rx, ry) {
            const point = transform({x, y, z}, rx, ry);
            const size = radius * point.size * 50;
            
            if (point.y > 0 && point.y < height) {
                const gradient = ctx.createRadialGradient(
                    point.x, point.y, 0,
                    point.x, point.y, size
                );
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, 'rgba(0,0,0,0.5)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawCylinder(x1, y1, z1, x2, y2, z2, radius, color, rx, ry) {
            const p1 = transform({x: x1, y: y1, z: z1}, rx, ry);
            const p2 = transform({x: x2, y: y2, z: z2}, rx, ry);
            
            const width = radius * ((p1.size + p2.size) / 2) * 50;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        function drawRobot() {
            rotationY = mouseX * Math.PI + time * 0.5;
            rotationX = mouseY * Math.PI * 0.3;
            
            const hoverY = Math.sin(time * 2) * 0.1;
            
            // Draw body parts in order (back to front for proper depth)
            
            // Back legs
            drawLeg(-0.7, -0.4, false, rotationX, rotationY, hoverY);
            drawLeg(0.7, -0.4, true, rotationX, rotationY, hoverY);
            
            // Middle legs
            drawLeg(-0.7, 0, false, rotationX, rotationY, hoverY);
            drawLeg(0.7, 0, true, rotationX, rotationY, hoverY);
            
            // Main body
            drawSphere(0, hoverY, 0, 0.8, '#3a3a3a', rotationX, rotationY);
            
            // Front legs
            drawLeg(-0.7, 0.4, false, rotationX, rotationY, hoverY);
            drawLeg(0.7, 0.4, true, rotationX, rotationY, hoverY);
            
            // Head
            drawSphere(0, 0.1 + hoverY, 1.0, 0.5, '#4a4a4a', rotationX, rotationY);
            
            // Antennae (AI sensors)
            drawCylinder(-0.2, 0.5 + hoverY, 1.2, -0.3, 0.9 + hoverY, 1.3, 0.02, '#4fc3f7', rotationX, rotationY);
            drawCylinder(0.2, 0.5 + hoverY, 1.2, 0.3, 0.9 + hoverY, 1.3, 0.02, '#4fc3f7', rotationX, rotationY);
            
            // Sensor tips (glowing)
            drawSphere(-0.3, 0.95 + hoverY, 1.3, 0.08, '#00ffff', rotationX, rotationY);
            drawSphere(0.3, 0.95 + hoverY, 1.3, 0.08, '#00ffff', rotationX, rotationY);
            
            // Magnetic field rings
            drawMagneticField(hoverY, rotationX, rotationY);
        }

        function drawLeg(xPos, zPos, isRight, rx, ry, hoverY) {
            const side = isRight ? 1 : -1;
            const legAngle = isRight ? Math.PI / 4 : -Math.PI / 4;
            
            // Upper leg
            const x1 = xPos;
            const y1 = -0.3 + hoverY;
            const z1 = zPos;
            const x2 = xPos + side * 0.3;
            const y2 = -0.7 + hoverY;
            const z2 = zPos;
            
            drawCylinder(x1, y1, z1, x2, y2, z2, 0.08, '#2c2c2c', rx, ry);
            
            // Lower leg
            const x3 = x2 + side * 0.15;
            const y3 = -1.0 + hoverY;
            const z3 = zPos;
            
            drawCylinder(x2, y2, z2, x3, y3, z3, 0.06, '#2c2c2c', rx, ry);
            
            // Foot
            drawSphere(x3, y3, z3, 0.06, '#2c2c2c', rx, ry);
        }

        function drawMagneticField(hoverY, rx, ry) {
            const rings = 2;
            for (let ring = 0; ring < rings; ring++) {
                const radius = 1.2 + ring * 0.3;
                const segments = 50;
                const opacity = 0.2 + Math.sin(time * 2) * 0.1;
                
                ctx.strokeStyle = `rgba(255, 0, 255, ${opacity})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2 + time * (ring % 2 === 0 ? 1 : -1);
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = hoverY;
                    
                    const p = transform({x, y, z}, rx, ry);
                    
                    if (i === 0) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
                ctx.stroke();
            }
        }

        function drawParticles() {
            particles.forEach((particle, i) => {
                particle.angle += particle.speed * 0.01;
                
                const x = Math.cos(particle.angle) * particle.radius;
                const z = Math.sin(particle.angle) * particle.radius;
                const y = Math.sin(time * 2 + particle.phase) * 0.5 + 1;
                
                const opacity = 0.4 + Math.sin(time * 3 + i) * 0.3;
                const point = transform({x, y, z}, rotationX, rotationY);
                const size = point.size * 20;
                
                ctx.fillStyle = `rgba(129, 199, 132, ${opacity})`;
                ctx.beginPath();
                ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawGrid() {
            const gridSize = 20;
            const gridDivisions = 20;
            const step = gridSize / gridDivisions;
            
            ctx.strokeStyle = 'rgba(79, 195, 247, 0.2)';
            ctx.lineWidth = 1;
            
            for (let i = -gridDivisions / 2; i <= gridDivisions / 2; i++) {
                const pos = i * step;
                
                // Lines parallel to X axis
                const p1 = transform({x: -gridSize / 2, y: -1, z: pos}, rotationX, rotationY);
                const p2 = transform({x: gridSize / 2, y: -1, z: pos}, rotationX, rotationY);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                
                // Lines parallel to Z axis
                const p3 = transform({x: pos, y: -1, z: -gridSize / 2}, rotationX, rotationY);
                const p4 = transform({x: pos, y: -1, z: gridSize / 2}, rotationX, rotationY);
                
                ctx.beginPath();
                ctx.moveTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.stroke();
            }
        }

        function animate() {
            time += 0.01;
            
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#0a1628');
            gradient.addColorStop(1, '#1a2642');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            drawGrid();
            
            // Draw sensor particles
            drawParticles();
            
            // Draw robot
            drawRobot();
            
            requestAnimationFrame(animate);
        }

        // Start the simulation
        init();
    </script>
</body>
</html>
